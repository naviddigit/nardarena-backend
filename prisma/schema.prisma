// This is your Prisma schema file
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// USER MANAGEMENT
// ==========================================

model User {
  id                    String    @id @default(uuid())
  email                 String    @unique
  username              String    @unique
  displayName           String?
  passwordHash          String?   // NULL for Google OAuth users
  googleId              String?   @unique
  
  // Profile fields
  avatar                String?   // Avatar URL or path
  country               String?   // ISO country code (e.g., 'US', 'IR')
  role                  UserRole  @default(USER) // User role
  isBot                 Boolean   @default(false) // Bot user for AI simulation
  
  // Account status
  status                UserStatus @default(ACTIVE)
  emailVerified         Boolean   @default(false)
  forcePasswordChange   Boolean   @default(false)
  
  // Security
  failedLoginAttempts   Int       @default(0)
  lastFailedLoginAt     DateTime?
  lockedUntil           DateTime?
  lastLoginAt           DateTime?
  
  // Timestamps
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  // Relations
  gamesAsWhite          Game[]    @relation("WhitePlayer")
  gamesAsBlack          Game[]    @relation("BlackPlayer")
  stats                 UserStats?
  userWallets           UserWallet[]
  deposits              Deposit[]
  withdrawals           Withdrawal[]
  transactions          Transaction[]
  adminActions          AdminAction[] @relation("AdminUser")
  targetedAdminActions  AdminAction[] @relation("TargetUser")
  
  @@index([email])
  @@index([username])
  @@index([status])
  @@index([googleId])
  @@index([isBot])
  @@map("users")
}

enum UserStatus {
  ACTIVE
  BANNED
  SUSPENDED
}

enum UserRole {
  USER
  ADMIN
}

// ==========================================
// USER STATISTICS
// ==========================================

model UserStats {
  userId              String   @id
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Game statistics
  gamesPlayed         Int      @default(0)
  gamesWon            Int      @default(0)
  gamesLost           Int      @default(0)
  gamesAbandoned      Int      @default(0)
  
  // Set statistics
  totalSetsWon        Int      @default(0)
  totalSetsLost       Int      @default(0)
  
  // Streaks
  currentStreak       Int      @default(0)
  bestStreak          Int      @default(0)
  
  // Playtime
  totalPlaytimeSeconds Int     @default(0)
  
  // Wallet balance (in USDT)
  balance             Decimal  @default(0) @db.Decimal(18, 6)
  
  updatedAt           DateTime @updatedAt
  
  @@map("user_stats")
}

// ==========================================
// GAME SETTINGS
// ==========================================

model GameSetting {
  id          String                  @id @default(uuid())
  key         String                  @unique
  value       String
  description String
  category    GameSettingCategory
  dataType    GameSettingDataType     @default(STRING)
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt
  
  @@index([category])
  @@map("game_settings")
}

enum GameSettingCategory {
  TIMING
  SCORING
  RULES
  BETS
  AI
}

enum GameSettingDataType {
  STRING
  NUMBER
  BOOLEAN
  JSON
}

// ==========================================
// GAME MANAGEMENT
// ==========================================

model Game {
  id                String      @id @default(uuid())
  
  // Players
  whitePlayerId     String
  blackPlayerId     String
  whitePlayer       User        @relation("WhitePlayer", fields: [whitePlayerId], references: [id])
  blackPlayer       User        @relation("BlackPlayer", fields: [blackPlayerId], references: [id])
  
  // Game type
  gameType          GameType    @default(AI) // AI, ONLINE, or TOURNAMENT
  
  // Game state (stored as JSON for flexibility)
  gameState         Json        // Current board state
  moveHistory       Json[]      // Array of all moves with timestamps
  
  // Game settings
  timeControl       Int         @default(120) // seconds per player (initial time per player)
  gameMode          GameMode    @default(CLASSIC)
  betAmount         Decimal?    @db.Decimal(18, 6) // NULL for non-bet games
  
  // Timer state (real-time remaining time for each player)
  whiteTimeRemaining Int?       // seconds remaining for white player (null = not started yet)
  blackTimeRemaining Int?       // seconds remaining for black player (null = not started yet)
  
  // ðŸŽ² Pre-generated dice for anti-cheat (generated at game creation)
  openingDiceWhite  Int?        // Opening roll for white (1-6)
  openingDiceBlack  Int?        // Opening roll for black (1-6)
  firstRollDice     Json?       // First 2d6 after opening winner determined [n, n]
  
  // Game result
  status            GameStatus  @default(ACTIVE)
  winner            PlayerColor?
  whiteSetsWon      Int         @default(0)
  blackSetsWon      Int         @default(0)
  endReason         EndReason?
  
  // Timestamps
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  startedAt         DateTime?
  endedAt           DateTime?
  
  // Relations
  moves             GameMove[]
  
  @@index([status, updatedAt])
  @@index([whitePlayerId])
  @@index([blackPlayerId])
  @@index([status])
  @@index([gameType])
  @@map("games")
}

enum GameMode {
  CLASSIC
  MODERN
  TOURNAMENT
}

enum GameType {
  AI         // Play against AI
  ONLINE     // Play against another player online
  TOURNAMENT // Part of a tournament
}

enum GameStatus {
  WAITING    // Waiting for players
  ACTIVE     // Game in progress
  COMPLETED  // Game finished normally
  ABANDONED  // Player left/timeout
  CANCELLED  // Cancelled by admin
}

enum PlayerColor {
  WHITE
  BLACK
}

enum EndReason {
  NORMAL_WIN
  RESIGNATION
  TIMEOUT
  ABANDONMENT
  ADMIN_CANCELLED
}

// ==========================================
// GAME MOVES (Detailed move tracking)
// ==========================================

model GameMove {
  id              String      @id @default(uuid())
  gameId          String
  game            Game        @relation(fields: [gameId], references: [id], onDelete: Cascade)
  
  // Move details
  playerColor     PlayerColor
  moveNumber      Int         // Sequential move number in the game
  
  // Move data
  from            Int         // Point number (0-23, or -1 for bar)
  to              Int         // Point number (0-23, or 24 for off)
  diceUsed        Int         // Which dice value was used for this move
  isHit           Boolean     @default(false) // Did this move hit opponent's checker?
  
  // Board state snapshot (optional - for replay/analysis)
  boardStateBefore Json?
  boardStateAfter  Json?
  
  // Timing
  timeRemaining   Int?        // Seconds remaining on player's clock
  moveTime        Int?        // Milliseconds taken to make this move
  
  createdAt       DateTime    @default(now())
  
  @@index([gameId, moveNumber])
  @@index([gameId])
  @@map("game_moves")
}

// ==========================================
// WALLET & CRYPTO MANAGEMENT
// ==========================================

// User wallets - each user has one wallet per network
model UserWallet {
  id                    String    @id @default(uuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  network               Network
  address               String    @unique
  encryptedPrivateKey   String    // AES-256-GCM encrypted
  salt                  String    // For PBKDF2
  
  balance               Decimal   @default(0) @db.Decimal(18, 6)
  lastCheckedAt         DateTime?
  
  isActive              Boolean   @default(true)
  createdAt             DateTime  @default(now())
  
  // Relations
  deposits              Deposit[]
  
  @@unique([userId, network])
  @@index([userId])
  @@index([address])
  @@index([createdAt])
  @@index([lastCheckedAt])
  @@map("user_wallets")
}

// Deposit transactions
model Deposit {
  id                String          @id @default(uuid())
  userId            String
  user              User            @relation(fields: [userId], references: [id])
  walletId          String
  wallet            UserWallet      @relation(fields: [walletId], references: [id])
  
  network           Network
  txHash            String          @unique
  fromAddress       String
  toAddress         String
  amount            Decimal         @db.Decimal(18, 6)
  blockNumber       BigInt?
  
  status            DepositStatus   @default(PENDING)
  confirmedAt       DateTime?
  
  createdAt         DateTime        @default(now())
  
  @@index([userId])
  @@index([walletId])
  @@index([status])
  @@index([txHash])
  @@index([createdAt])
  @@map("deposits")
}

enum DepositStatus {
  PENDING
  CONFIRMED
  FAILED
}

// Withdrawal requests
model Withdrawal {
  id                String            @id @default(uuid())
  userId            String
  user              User              @relation(fields: [userId], references: [id])
  
  network           Network
  toAddress         String
  amount            Decimal           @db.Decimal(18, 6)
  networkFee        Decimal           @db.Decimal(18, 6)
  serviceFee        Decimal           @db.Decimal(18, 6)
  totalFee          Decimal           @db.Decimal(18, 6)
  
  txHash            String?           @unique
  status            WithdrawalStatus  @default(PENDING)
  adminNote         String?
  
  requestedAt       DateTime          @default(now())
  processedAt       DateTime?
  completedAt       DateTime?
  
  @@index([userId])
  @@index([status])
  @@index([txHash])
  @@index([requestedAt])
  @@map("withdrawals")
}

enum WithdrawalStatus {
  PENDING       // Waiting for processing
  PROCESSING    // Transaction in progress
  COMPLETED     // Successfully completed
  FAILED        // Transaction failed
  REJECTED      // Rejected by admin
}

// Master wallets for settlements
model MasterWallet {
  id                    String    @id @default(uuid())
  network               Network   @unique
  address               String    @unique
  encryptedPrivateKey   String    // AES-256-GCM encrypted
  salt                  String    // For PBKDF2
  
  isActive              Boolean   @default(true)
  createdAt             DateTime  @default(now())
  lastSettlementAt      DateTime?
  
  @@map("master_wallets")
}

// System-wide settings
model SystemSetting {
  key           String    @id
  value         String
  description   String?
  category      String    // 'api', 'network', 'withdraw', 'fee', 'master_wallet'
  updatedAt     DateTime  @updatedAt
  
  @@index([category])
  @@map("system_settings")
}

enum Network {
  TRC20   // Tron Network (USDT)
  BSC     // Binance Smart Chain (USDT)
}

model Transaction {
  id            String            @id @default(uuid())
  userId        String
  user          User              @relation(fields: [userId], references: [id])
  
  type          TransactionType
  amount        Decimal           @db.Decimal(18, 6)
  network       Network
  
  // Blockchain data
  txHash        String?           @unique
  fromAddress   String?
  toAddress     String?
  
  // Status
  status        TransactionStatus @default(PENDING)
  
  // Metadata
  metadata      Json?             // Additional data (gas, confirmations, etc)
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  completedAt   DateTime?
  
  @@index([userId])
  @@index([status])
  @@index([txHash])
  @@index([type, createdAt])
  @@map("transactions")
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  GAME_WIN
  GAME_LOSS
  ADMIN_ADJUSTMENT
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  COMPLETED
  FAILED
  CANCELLED
}

// ==========================================
// ADMIN MANAGEMENT
// ==========================================

model AdminAction {
  id              String       @id @default(uuid())
  
  // Admin who performed action
  adminId         String
  admin           User         @relation("AdminUser", fields: [adminId], references: [id])
  
  // Target user (if applicable)
  targetUserId    String?
  targetUser      User?        @relation("TargetUser", fields: [targetUserId], references: [id])
  
  // Action details
  actionType      AdminActionType
  reason          String?
  metadata        Json?        // Additional data (ban duration, etc)
  
  // Request metadata
  ipAddress       String?
  
  createdAt       DateTime     @default(now())
  
  @@index([adminId])
  @@index([targetUserId])
  @@index([actionType, createdAt])
  @@map("admin_actions")
}

enum AdminActionType {
  BAN_USER
  UNBAN_USER
  DELETE_USER
  RESET_PASSWORD
  ADJUST_BALANCE
  CANCEL_GAME
  VERIFY_EMAIL
  SYSTEM_MESSAGE
}

// ==========================================
// SESSION MANAGEMENT (Optional - for refresh tokens)
// ==========================================

model RefreshToken {
  id          String   @id @default(uuid())
  userId      String
  token       String   @unique
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  
  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}
